<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EW Library: Thin-Plate Spline with Semi-landmarks on Affine Subspaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Thin-Plate Spline with Semi-landmarks on Affine Subspaces </h1>  </div>
</div>
<div class="contents">
<p>Suppose we have <em>n_lmks</em> landmarks in <img class="formulaInl" alt="$\mathbb{R}^D$" src="form_0.png"/>, where D is 2 or 3. Let <em>lmks</em> be the <em>n_lmks</em> x D matrix with rows the landmark coordinates.</p>
<p>A thin-plate spline is a linear combination of these functions <img class="formulaInl" alt="$\mathbb{R}^D\to\mathbb{R}$" src="form_1.png"/>:</p>
<ul>
<li>the constant function 1</li>
<li>the linear function x</li>
<li>the linear function y</li>
<li>(if D = 3) the linear function z</li>
<li>the radial basis function at landmark 1</li>
<li>...</li>
<li>the radial basis function at landmark <em>n_lmks</em> </li>
</ul>
<p>A D-valued thin-plate spline is a function <img class="formulaInl" alt="$\mathbb{R}^D\to\mathbb{R}^D$" src="form_2.png"/>, consisting of D single-valued thin-plate splines, one in each of the x, y and (if D = 3) z directions. It can be represented as <em>spline</em>, the (1 + D + <em>n_lmks</em>) x D matrix of the coefficients of the corresponding linear combinations.</p>
<p>Let <em>lmk_images</em> be the <em>n_lmks</em> x D matrix with rows the images of the landmarks under the spline. Let <em>aff_lmk_images</em> denote the (1 + D + <em>n_lmks</em>) x D matrix with first 1 + D rows zero (corresponding to the affine spline components) and remaining rows the rows of <em>lmk_images</em>. Then </p>
<center> <em>L</em> * <em>spline</em> = <em>aff_lmk_images</em> </center><p> where <em>L</em> is a (1 + D + <em>n_lmks</em>) x (1 + D + <em>n_lmks</em>) matrix that is calculated from <em>lmks</em>. <em>L</em> can be viewed as the matrix of landmark interactions.</p>
<p>A semi-landmark is a landmark for which, instead of an image, an affine subspace of <img class="formulaInl" alt="$\mathbb{R}^D$" src="form_0.png"/> is specified. A normal landmark can be considered a semi-landmark with an affine space of dimension 0. A D-valued thin-plate spline with semi-landmarks is a thin-plate spline that minimizes bending energy while mapping every semi-landmark into its corresponding affine subspace. The spline is allowed to 'relax' (minimize energy) by sliding the semi-landmark images along their 'relaxation' subspaces.</p>
<p>These affine subspaces will be specified here as linear spaces about the points that are the rows of <em>lmk_images</em>. Let <em>relax_dims</em> be the integer vector of length <em>n_lmks</em>, consisting of the dimensions of these affine spaces. It's elements can be</p>
<ul>
<li>0 The semi-landmark is a regular landmark.</li>
<li>1 The semi-landmark is a semi-landmark relaxed along a line.</li>
<li>2 The semi-landmark is a semi-landmark relaxed along a plane (in 3D) or is ignored (in 2D).</li>
<li>3 (3D only) The semi-landmark is ignored.</li>
</ul>
<p>The relaxation subspaces can be defined by a <em>n_lmks</em> x D matrix, <em>relax_params</em>. For regular landmarks and ignored semi-landmarks, the corresponding row of <em>relax_params</em> is unused. For codimension 1 affine spaces, the corresponding row of <em>relax_params</em> should be a unit vector normal to the space. For semi-landmarks along a line in 3D, the corresponding row of <em>relax_params</em> should be a unit vector normal in the direction of the line.</p>
<p>Our problem, then, is to find the spline <em>spline</em> that minimizes energy, given <em>lmks</em>, <em>lmk_images</em>, <em>relax_dims</em> and <em>relax_params</em>. Let <em>relax_lmk_images</em> be the <em>n_lmks</em> x D matrix of the coordinates of the images of the semi-landmarks under the relaxed spline.</p>
<p>Rewrite </p>
<center> <em>L</em> * <em>spline</em> = <em>aff_relax_lmk_images</em> </center><p> as a simple equation in (1 + D + <em>n_lmks</em>) * D variables </p>
<center> <em>L3</em> * <em>spline_flat</em> = <em>aff_relax_lmk_images_flat</em> </center><p> where <em>spline_flat</em> is the vector formed by concatenating the rows of <em>spline</em>, <em>aff_relax_lmk_images_flat</em> is the vector formed by concatenating the rows of <em>aff_relax_lmk_images</em>, and <em>L3</em> is the matrix formed by replacing each element of <em>L</em> by the D x D identity matrix multiplied by that element.</p>
<p>The constraint on the relaxed spline is that </p>
<center> <em>aff_relax_lmk_images_flat</em> - <em>aff_lmk_images_flat</em> </center><p> must be in the direct sum of the linear parts of the relaxation spaces. The energy of the spline is the dot product of <em>spline_flat</em> and <em>aff_relax_lmk_images_flat</em>. Hence, the energy will be minimized when <em>spline_flat</em> is orthogonal to this direct sum.</p>
<p>Construct a matrix <em>R</em> as follows. <em>R</em> is a block matrix, with (1 + D + <em>n_lmks</em>) x (1 + D + <em>n_lmks</em>) blocks and all off diagonal blocks zero. The first 1 + D on-diagonal blocks are D x D identity matrices The remaining on-diagonal blocks depend on the dimension of the relax space of the corresponding semi-landmark. If D = 2:</p>
<ul>
<li>0: a D x D identity matrix</li>
<li>1: a D x 1 column vector equal to the corresponding part of <em>relax_params</em> </li>
<li>2: a D x 0 empty matrix</li>
</ul>
<p>If D = 3:</p>
<ul>
<li>0: a D x D identity matrix</li>
<li>1: a D x 2 matrix with 2 independent column vectors perpendicular to the corresponding part of <em>relax_params</em> </li>
<li>2: a D x 1 column vector equal to the corresponding part of <em>relax_params</em> </li>
<li>3: a D x 0 empty matrix</li>
</ul>
<p>Then the columns of <em>R</em> form a basis of the orthogonal complement to the direct of the linear parts of the relaxation spaces. Hence <em>spline_flat</em> is a linear combination of these columns, and we can write </p>
<center> <em>spline_flat</em> = <em>R</em> * <em>spline_flat_reduced</em> </center><p> for some vector <em>spline_flat_reduced</em>. Also </p>
<center> <em>R'</em> * <em>aff_relax_lmk_images_flat</em> = <em>R'</em> * <em>aff_lmk_images_flat</em> </center><p> where <em>R'</em> is the transpose of <em>R</em>. The spline equation then becomes </p>
<center> (<em>R'</em> * <em>L3</em> * <em>R</em>) * <em>spline_flat_reduced</em> = <em>aff_lmk_images_flat_reduced</em> </center><p> where </p>
<center> <em>aff_lmk_images_flat_reduced</em> = <em>R'</em> * <em>aff_lmk_images_flat</em> </center><p> In the general case, this is the equation factored by <a class="el" href="classew_1_1Tps2.html#a07f500b8a093d45384ee6d90dd2c226a">ew::Tps2::factorize</a> or <a class="el" href="classew_1_1Tps3.html#abc71d05432b69dcaab46b5a2e2dc5e2a">ew::Tps3::factorize</a>, and solved by <a class="el" href="classew_1_1Tps2.html#a4691d5181d87c9219d8fec679cfccdcc">ew::Tps2::solve</a> or <a class="el" href="classew_1_1Tps3.html#acf2ff420aa319fa03e4ae0efbdbb420a">ew::Tps3::solve</a>.</p>
<p>If there are only trivial semi-landmarks (the relax space has dimension 0 or D), the matrix <em>R'</em> * <em>L3</em> * <em>R</em> is, like <em>L3</em>, block diagonal. This is the case <em>is_mixed</em> = <code>false</code>. In this case, we don't need to invert (<em>R'</em> * <em>L3</em> * <em>R</em>), rather just one of the diagonal blocks, which is just <em>L</em> with the rows and columns of the ignored landmarks deleted. This is the matrix factored by <a class="el" href="classew_1_1Tps2.html#a07f500b8a093d45384ee6d90dd2c226a">ew::Tps2::factorize</a> or <a class="el" href="classew_1_1Tps3.html#abc71d05432b69dcaab46b5a2e2dc5e2a">ew::Tps3::factorize</a>. <a class="el" href="classew_1_1Tps2.html#a4691d5181d87c9219d8fec679cfccdcc">ew::Tps2::solve</a> or <a class="el" href="classew_1_1Tps3.html#acf2ff420aa319fa03e4ae0efbdbb420a">ew::Tps3::solve</a> then solve the 3 sets of equations. With no semi-landmarks, this reverts to the original equation.</p>
<p>Non-trivial semi-landmarks introduce an interaction between the components of the D-valued spline, and we cannot factor the equation as we've presented it.</p>
<p>Let <em>r</em> be the sum of the dimensions of the relax spaces. Then <em>f_size</em>, the size of the matrix the algorithm factors is as follows:</p>
<ul>
<li>if <em>is_reduced</em> is <code>false</code>, <em>f_size</em> is 1 + D + <em>n_lmks</em>,</li>
<li>if <em>is_mixed</em> is <code>false</code>, <em>f_size</em> is 1 + D + <em>n_lmks</em> - <em>r</em> / D,</li>
<li>otherwise, <em>f_size</em> is D * (1 + D + <em>n_lmks</em>) - <em>r</em>.</li>
</ul>
<p>An alternative algorithm would be to invert <em>L</em>, calculate the bending energy relative to a basis of the relaxation space as a quadratic function, and then minimize this quadratic function. This would involve inverting a matrix of size 1 + D + <em>n_lmks</em> and then diagonalizing a quadratic form of size <em>r</em>. Clearly, for small non-zero <em>r</em>, this would be faster (none of this applies if <em>r</em> is zero, or more generally if <em>is_mixed</em> is <code>false</code>). On the other hand, this would be slower for a spline in 3D with mostly plane semi-landmarks, where <em>r</em> approached (D - 1) * <em>n_lmks</em>. This is exactly the case where we are likely to encounter a very large number of landmarks, and it is the case for which this code has been optimized. </p>
</div>
<hr size="1"><address style="text-align: right;"><small>
EW Library documentation
</small></address>
</body>
</html>
